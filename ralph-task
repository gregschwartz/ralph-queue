#!/bin/bash
# ralph-task - Unified task management CLI for Ralph
# Supports multiple storage backends: directory, beads, github
#
# Usage:
#   ralph-task add "task description" [-p H|M|L] [--project NAME]
#   ralph-task list [--project NAME] [--status pending|done|all]
#   ralph-task next [--project NAME]
#   ralph-task show <task-id>
#   ralph-task done [task-id]
#   ralph-task skip [task-id]
#   ralph-task edit <task-id>
#   ralph-task delete <task-id>
#   ralph-task queue [--load]  # Show queue or load next task into PROMPT.md

set -euo pipefail

# Configuration
RALPH_TASK_STORAGE="${RALPH_TASK_STORAGE:-directory}"  # directory, beads, github
RALPH_TASK_DIRS="${RALPH_TASK_DIRS:-}"  # Comma-separated directories for 'directory' backend
RALPH_TASK_DEFAULT_PROJECT="${RALPH_TASK_DEFAULT_PROJECT:-}"
RALPH_TASK_DONE_SUBDIR="${RALPH_TASK_DONE_SUBDIR:-done}"
RALPH_DIR="${RALPH_DIR:-.ralph}"
RALPH_TASK_CURRENT_FILE="${RALPH_DIR}/.current_task"
RALPH_TASK_QUEUE_FILE="${RALPH_DIR}/.task_queue"

# Priority order
PRIORITIES="H M L"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Load config from .ralphrc if exists
load_config() {
    if [[ -f ".ralphrc" ]]; then
        # shellcheck source=/dev/null
        source ".ralphrc"
    fi
    if [[ -f "$HOME/.ralphrc" ]]; then
        # shellcheck source=/dev/null
        source "$HOME/.ralphrc"
    fi
}

# ============================================================================
# Storage Backend: Directory
# ============================================================================

dir_find_task_dirs() {
    if [[ -n "$RALPH_TASK_DIRS" ]]; then
        echo "$RALPH_TASK_DIRS" | tr ',' '\n'
        return
    fi

    # Auto-discover: look for */tasks directories
    find . -maxdepth 2 -type d -name "tasks" 2>/dev/null | grep -v node_modules | grep -v ".ralph"
}

dir_add() {
    local description="$1"
    local priority="${2:-M}"
    local project="${3:-}"

    # Normalize priority
    priority=$(echo "$priority" | tr '[:lower:]' '[:upper:]' | cut -c1)
    case "$priority" in
        H|M|L) ;;
        *) priority="M" ;;
    esac

    # Determine target directory
    local task_dir
    if [[ -n "$project" ]]; then
        task_dir="${project}/tasks"
    elif [[ -n "$RALPH_TASK_DEFAULT_PROJECT" ]]; then
        task_dir="${RALPH_TASK_DEFAULT_PROJECT}/tasks"
    else
        # Use first available tasks dir or create ./tasks
        task_dir=$(dir_find_task_dirs | head -1)
        if [[ -z "$task_dir" ]]; then
            task_dir="./tasks"
        fi
    fi

    mkdir -p "$task_dir"
    mkdir -p "${task_dir}/${RALPH_TASK_DONE_SUBDIR}"

    # Generate filename
    local timestamp
    timestamp=$(date +%s)
    local slug
    slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/_/g' | sed 's/_\{1,\}/_/g' | sed 's/^_//;s/_$//' | cut -c1-40)
    local filename="${priority}_${timestamp}_${slug}.md"
    local filepath="${task_dir}/${filename}"

    # Create task file
    cat > "$filepath" << EOF
# ${description}

**Priority:** ${priority}
**Created:** $(date)
**Status:** Active

## Description
${description}

## Subtasks
- [ ]

## Notes


## Blockers
None
EOF

    echo -e "${GREEN}Created:${NC} ${filepath}"
    echo "$filepath"
}

dir_list() {
    local project="${1:-}"
    local status="${2:-pending}"

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for dir in $dirs; do
        [[ ! -d "$dir" ]] && continue

        local project_name
        project_name=$(dirname "$dir" | xargs basename)

        if [[ "$status" == "pending" || "$status" == "all" ]]; then
            for pri in $PRIORITIES; do
                for file in "$dir"/${pri}_*.md; do
                    [[ ! -f "$file" ]] && continue
                    local title
                    title=$(grep -m1 '^# ' "$file" 2>/dev/null | sed 's/^# //' || basename "$file" .md)
                    local pri_color
                    case "$pri" in
                        H) pri_color="$RED" ;;
                        M) pri_color="$YELLOW" ;;
                        L) pri_color="$BLUE" ;;
                    esac
                    echo -e "[${pri_color}${pri}${NC}] [${project_name}] ${title}"
                    echo "    ${file}"
                done
            done
        fi

        if [[ "$status" == "done" || "$status" == "all" ]]; then
            local done_dir="${dir}/${RALPH_TASK_DONE_SUBDIR}"
            if [[ -d "$done_dir" ]]; then
                for file in "$done_dir"/*.md; do
                    [[ ! -f "$file" ]] && continue
                    local title
                    title=$(grep -m1 '^# ' "$file" 2>/dev/null | sed 's/^# //' || basename "$file" .md)
                    echo -e "[${GREEN}âœ“${NC}] [${project_name}] ${title}"
                    echo "    ${file}"
                done
            fi
        fi
    done
}

dir_next() {
    local project="${1:-}"

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for pri in $PRIORITIES; do
        for dir in $dirs; do
            [[ ! -d "$dir" ]] && continue
            for file in "$dir"/${pri}_*.md; do
                [[ -f "$file" ]] && echo "$file" && return 0
            done
        done
    done

    return 1
}

dir_show() {
    local task_id="$1"

    # task_id can be full path or partial match
    local file
    if [[ -f "$task_id" ]]; then
        file="$task_id"
    else
        file=$(find . -path "*tasks*${task_id}*" -name "*.md" -not -path "*/${RALPH_TASK_DONE_SUBDIR}/*" 2>/dev/null | head -1)
    fi

    if [[ -z "$file" || ! -f "$file" ]]; then
        echo -e "${RED}Task not found:${NC} $task_id" >&2
        return 1
    fi

    cat "$file"
    echo ""
    echo -e "${BLUE}File:${NC} $file"
}

dir_done() {
    local task_id="${1:-}"

    local file
    if [[ -z "$task_id" ]]; then
        # Use current task
        if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
            file=$(cat "$RALPH_TASK_CURRENT_FILE")
        else
            echo -e "${RED}No current task. Specify task ID.${NC}" >&2
            return 1
        fi
    elif [[ -f "$task_id" ]]; then
        file="$task_id"
    else
        file=$(find . -path "*tasks*${task_id}*" -name "*.md" -not -path "*/${RALPH_TASK_DONE_SUBDIR}/*" 2>/dev/null | head -1)
    fi

    if [[ -z "$file" || ! -f "$file" ]]; then
        echo -e "${RED}Task not found:${NC} $task_id" >&2
        return 1
    fi

    local task_dir
    task_dir=$(dirname "$file")
    local done_dir="${task_dir}/${RALPH_TASK_DONE_SUBDIR}"
    mkdir -p "$done_dir"

    local basename
    basename=$(basename "$file")
    local date_prefix
    date_prefix=$(date +%Y-%m-%d)
    local new_name="${date_prefix}_${basename}"

    mv "$file" "${done_dir}/${new_name}"

    # Clear current task if it matches
    if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
        local current
        current=$(cat "$RALPH_TASK_CURRENT_FILE")
        if [[ "$current" == "$file" ]]; then
            rm -f "$RALPH_TASK_CURRENT_FILE"
        fi
    fi

    echo -e "${GREEN}Done:${NC} ${done_dir}/${new_name}"
}

dir_count() {
    local project="${1:-}"
    local count=0

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for dir in $dirs; do
        [[ ! -d "$dir" ]] && continue
        count=$((count + $(find "$dir" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')))
    done

    echo "$count"
}

# ============================================================================
# Queue Management
# ============================================================================

queue_build() {
    local project="${1:-}"

    mkdir -p "$RALPH_DIR"

    # Build prioritized queue
    local queue=()

    for pri in $PRIORITIES; do
        while IFS= read -r file; do
            [[ -n "$file" ]] && queue+=("$file")
        done < <(
            local dirs
            if [[ -n "$project" ]]; then
                dirs="${project}/tasks"
            else
                dirs=$(dir_find_task_dirs)
            fi
            for dir in $dirs; do
                [[ -d "$dir" ]] && ls -1 "$dir"/${pri}_*.md 2>/dev/null | sort
            done
        )
    done

    printf '%s\n' "${queue[@]}" > "$RALPH_TASK_QUEUE_FILE"
    echo "${#queue[@]}"
}

queue_next() {
    if [[ ! -f "$RALPH_TASK_QUEUE_FILE" ]]; then
        queue_build > /dev/null
    fi

    grep -v '^$' "$RALPH_TASK_QUEUE_FILE" 2>/dev/null | head -1
}

queue_load() {
    local task
    task=$(queue_next)

    if [[ -z "$task" ]]; then
        echo -e "${YELLOW}No tasks in queue${NC}"
        return 1
    fi

    # Save as current task
    echo "$task" > "$RALPH_TASK_CURRENT_FILE"

    # Remove from queue
    sed -i '' "1d" "$RALPH_TASK_QUEUE_FILE" 2>/dev/null || sed -i "1d" "$RALPH_TASK_QUEUE_FILE"

    # Generate PROMPT.md
    local title
    title=$(grep -m1 '^# ' "$task" 2>/dev/null | sed 's/^# //' || basename "$task" .md)

    local task_content
    task_content=$(cat "$task")

    local project_name
    project_name=$(dirname "$(dirname "$task")" | xargs basename)

    mkdir -p "$RALPH_DIR"
    cat > "${RALPH_DIR}/PROMPT.md" << EOF
# Current Task: ${title}

## Project
Working on: **${project_name}**

## Task Details
${task_content}

## Instructions
1. Complete the task described above
2. Commit your changes with a descriptive message
3. When fully complete, output: TASK_COMPLETE
4. If blocked or need human input, output: TASK_BLOCKED: <reason>

## Important
- Focus ONLY on this task
- Do not proceed past any STOP markers without explicit approval
- If the task is unclear, ask for clarification
EOF

    echo -e "${GREEN}Loaded:${NC} ${title}"
    echo -e "${BLUE}File:${NC} ${task}"
    echo -e "${BLUE}Prompt:${NC} ${RALPH_DIR}/PROMPT.md"
}

queue_current() {
    if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
        cat "$RALPH_TASK_CURRENT_FILE"
    fi
}

queue_skip() {
    local current
    current=$(queue_current)

    if [[ -z "$current" ]]; then
        echo -e "${YELLOW}No current task to skip${NC}"
        return 0
    fi

    # Add back to end of queue
    echo "$current" >> "$RALPH_TASK_QUEUE_FILE"
    rm -f "$RALPH_TASK_CURRENT_FILE"

    echo -e "${YELLOW}Skipped:${NC} $current"
}

# ============================================================================
# Main CLI
# ============================================================================

usage() {
    cat << 'EOF'
ralph-task - Unified task management for Ralph

USAGE:
    ralph-task <command> [options]

COMMANDS:
    add <description>     Add a new task
        -p, --priority    Priority: H (high), M (medium), L (low). Default: M
        --project         Target project directory

    list                  List all tasks
        --project         Filter by project
        --status          Filter: pending, done, all. Default: pending

    next                  Show next task in queue
        --project         Filter by project

    show <task-id>        Show task details (partial match supported)

    done [task-id]        Mark task as done (default: current task)

    skip                  Skip current task (move to end of queue)

    queue                 Show queue status
        --load            Load next task into PROMPT.md

    count                 Count pending tasks

    help                  Show this help

CONFIGURATION (.ralphrc):
    RALPH_TASK_STORAGE=directory     # Storage backend
    RALPH_TASK_DIRS=a/tasks,b/tasks  # Task directories
    RALPH_TASK_DEFAULT_PROJECT=ios   # Default project for 'add'

ALIASES (add to .zshrc/.bashrc):
    alias rt='ralph-task'
    alias rta='ralph-task add'
    alias rtl='ralph-task list'
    alias rtn='ralph-task next'
    alias rtd='ralph-task done'

EXAMPLES:
    ralph-task add "fix login bug" -p h
    ralph-task add "update docs" --project backend
    ralph-task list --status all
    ralph-task done fix_login
    ralph-task queue --load
EOF
}

main() {
    load_config

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add|a)
            local description=""
            local priority="M"
            local project=""

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    -p|--priority)
                        priority="$2"
                        shift 2
                        ;;
                    --project)
                        project="$2"
                        shift 2
                        ;;
                    -*)
                        echo "Unknown option: $1" >&2
                        return 1
                        ;;
                    *)
                        if [[ -z "$description" ]]; then
                            description="$1"
                        else
                            description="$description $1"
                        fi
                        shift
                        ;;
                esac
            done

            if [[ -z "$description" ]]; then
                echo -e "${RED}Error: Task description required${NC}" >&2
                return 1
            fi

            dir_add "$description" "$priority" "$project"
            ;;

        list|ls|l)
            local project=""
            local status="pending"

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --project) project="$2"; shift 2 ;;
                    --status) status="$2"; shift 2 ;;
                    *) shift ;;
                esac
            done

            dir_list "$project" "$status"
            ;;

        next|n)
            local project=""
            [[ "${1:-}" == "--project" ]] && project="$2"

            local next
            next=$(dir_next "$project")
            if [[ -n "$next" ]]; then
                dir_show "$next"
            else
                echo -e "${YELLOW}No pending tasks${NC}"
            fi
            ;;

        show|s)
            dir_show "${1:-}"
            ;;

        done|d|complete)
            dir_done "${1:-}"
            ;;

        skip)
            queue_skip
            ;;

        queue|q)
            if [[ "${1:-}" == "--load" ]]; then
                queue_load
            else
                local count
                count=$(queue_build)
                echo -e "${BLUE}Queue:${NC} ${count} tasks"

                local current
                current=$(queue_current)
                if [[ -n "$current" ]]; then
                    local title
                    title=$(grep -m1 '^# ' "$current" 2>/dev/null | sed 's/^# //' || basename "$current" .md)
                    echo -e "${GREEN}Current:${NC} ${title}"
                    echo "         ${current}"
                fi

                echo ""
                echo "Pending:"
                dir_list "" "pending"
            fi
            ;;

        count|c)
            dir_count "${1:-}"
            ;;

        help|--help|-h)
            usage
            ;;

        *)
            echo -e "${RED}Unknown command:${NC} $cmd" >&2
            echo "Run 'ralph-task help' for usage"
            return 1
            ;;
    esac
}

# Run if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
