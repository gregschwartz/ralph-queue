#!/bin/bash
# ralph-tasks - Unified task management CLI for Ralph
# Supports multiple storage backends: directory, beads, github
#
# Usage:
#   ralph-tasks "task description"                  # Add medium priority task
#   ralph-tasks h "high priority task"              # Add high priority task
#   ralph-tasks l "low priority task"               # Add low priority task
#   ralph-tasks list [--project NAME] [--status pending|done|all]
#   ralph-tasks next [--project NAME]
#   ralph-tasks show <task-id>
#   ralph-tasks done [task-id]
#   ralph-tasks skip [task-id]
#   ralph-tasks queue [--load]  # Show queue or load next task into PROMPT.md
#   ralph-tasks start           # Process all tasks automatically

set -euo pipefail

# Configuration
RALPH_TASK_STORAGE="${RALPH_TASK_STORAGE:-directory}"  # directory, beads, github
RALPH_TASK_DIRS="${RALPH_TASK_DIRS:-}"  # Comma-separated directories for 'directory' backend
RALPH_TASK_DEFAULT_PROJECT="${RALPH_TASK_DEFAULT_PROJECT:-}"
RALPH_TASK_DONE_SUBDIR="${RALPH_TASK_DONE_SUBDIR:-done}"
RALPH_TASK_FAILED_SUBDIR="${RALPH_TASK_FAILED_SUBDIR:-failed}"
RALPH_LOOP_MAX_ITERATIONS="${RALPH_LOOP_MAX_ITERATIONS:-20}"
RALPH_LOOP_SCRIPT="${RALPH_LOOP_SCRIPT:-$HOME/.ralph/ralph_loop.sh}"
RALPH_DIR="${RALPH_DIR:-.ralph}"
RALPH_TASK_CURRENT_FILE="${RALPH_DIR}/.current_task"
RALPH_TASK_QUEUE_FILE="${RALPH_DIR}/.task_queue"
RALPH_TASK_ATTEMPTS_FILE="${RALPH_DIR}/.task_attempts"
RALPH_TASK_MAX_ATTEMPTS="${RALPH_TASK_MAX_ATTEMPTS:-3}"

# Priority order
PRIORITIES="H M L"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Load config from .ralphrc if exists
load_config() {
    if [[ -f ".ralphrc" ]]; then
        # shellcheck source=/dev/null
        source ".ralphrc"
    fi
    if [[ -f "$HOME/.ralphrc" ]]; then
        # shellcheck source=/dev/null
        source "$HOME/.ralphrc"
    fi
}

# ============================================================================
# Storage Backend: Directory
# ============================================================================

dir_find_task_dirs() {
    if [[ -n "$RALPH_TASK_DIRS" ]]; then
        echo "$RALPH_TASK_DIRS" | tr ',' '\n'
        return
    fi

    # Auto-discover: look for */tasks directories
    find . -maxdepth 2 -type d -name "tasks" 2>/dev/null | grep -v node_modules | grep -v ".ralph"
}

dir_add() {
    local description="$1"
    local priority="${2:-M}"
    local project="${3:-}"

    # Normalize priority
    priority=$(echo "$priority" | tr '[:lower:]' '[:upper:]' | cut -c1)
    case "$priority" in
        H|M|L) ;;
        *) priority="M" ;;
    esac

    # Determine target directory
    local task_dir
    if [[ -n "$project" ]]; then
        task_dir="${project}/tasks"
    elif [[ -n "$RALPH_TASK_DEFAULT_PROJECT" ]]; then
        task_dir="${RALPH_TASK_DEFAULT_PROJECT}/tasks"
    else
        # Use first available tasks dir or create ./tasks
        task_dir=$(dir_find_task_dirs | head -1)
        if [[ -z "$task_dir" ]]; then
            task_dir="./tasks"
        fi
    fi

    mkdir -p "$task_dir"
    mkdir -p "${task_dir}/${RALPH_TASK_DONE_SUBDIR}"

    # Generate filename
    local timestamp
    timestamp=$(date +%s)
    local slug
    slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/_/g' | sed 's/_\{1,\}/_/g' | sed 's/^_//;s/_$//' | cut -c1-40)
    local filename="${priority}_${timestamp}_${slug}.md"
    local filepath="${task_dir}/${filename}"

    # Create task file
    cat > "$filepath" << EOF
# ${description}

**Priority:** ${priority}
**Created:** $(date)
**Status:** Active

## Description
${description}

## Subtasks
- [ ]

## Notes


## Blockers
None
EOF

    echo -e "${GREEN}Created:${NC} ${filepath}"
    echo "$filepath"
}

dir_list() {
    local project="${1:-}"
    local status="${2:-pending}"

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for dir in $dirs; do
        [[ ! -d "$dir" ]] && continue

        local project_name
        project_name=$(dirname "$dir" | xargs basename)

        if [[ "$status" == "pending" || "$status" == "all" ]]; then
            for pri in $PRIORITIES; do
                for file in "$dir"/${pri}_*.md; do
                    [[ ! -f "$file" ]] && continue
                    local title
                    title=$(grep -m1 '^# ' "$file" 2>/dev/null | sed 's/^# //' || basename "$file" .md)
                    local pri_color
                    case "$pri" in
                        H) pri_color="$RED" ;;
                        M) pri_color="$YELLOW" ;;
                        L) pri_color="$BLUE" ;;
                    esac
                    echo -e "[${pri_color}${pri}${NC}] [${project_name}] ${title}"
                    echo "    ${file}"
                done
            done
        fi

        if [[ "$status" == "done" || "$status" == "all" ]]; then
            local done_dir="${dir}/${RALPH_TASK_DONE_SUBDIR}"
            if [[ -d "$done_dir" ]]; then
                for file in "$done_dir"/*.md; do
                    [[ ! -f "$file" ]] && continue
                    local title
                    title=$(grep -m1 '^# ' "$file" 2>/dev/null | sed 's/^# //' || basename "$file" .md)
                    echo -e "[${GREEN}âœ“${NC}] [${project_name}] ${title}"
                    echo "    ${file}"
                done
            fi
        fi
    done
}

dir_next() {
    local project="${1:-}"

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for pri in $PRIORITIES; do
        for dir in $dirs; do
            [[ ! -d "$dir" ]] && continue
            for file in "$dir"/${pri}_*.md; do
                [[ -f "$file" ]] && echo "$file" && return 0
            done
        done
    done

    return 1
}

dir_show() {
    local task_id="$1"

    # task_id can be full path or partial match
    local file
    if [[ -f "$task_id" ]]; then
        file="$task_id"
    else
        file=$(find . -path "*tasks*${task_id}*" -name "*.md" -not -path "*/${RALPH_TASK_DONE_SUBDIR}/*" 2>/dev/null | head -1)
    fi

    if [[ -z "$file" || ! -f "$file" ]]; then
        echo -e "${RED}Task not found:${NC} $task_id" >&2
        return 1
    fi

    cat "$file"
    echo ""
    echo -e "${BLUE}File:${NC} $file"
}

dir_done() {
    local task_id="${1:-}"

    local file
    if [[ -z "$task_id" ]]; then
        # Use current task
        if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
            file=$(cat "$RALPH_TASK_CURRENT_FILE")
        else
            echo -e "${RED}No current task. Specify task ID.${NC}" >&2
            return 1
        fi
    elif [[ -f "$task_id" ]]; then
        file="$task_id"
    else
        file=$(find . -path "*tasks*${task_id}*" -name "*.md" -not -path "*/${RALPH_TASK_DONE_SUBDIR}/*" 2>/dev/null | head -1)
    fi

    if [[ -z "$file" || ! -f "$file" ]]; then
        echo -e "${RED}Task not found:${NC} $task_id" >&2
        return 1
    fi

    local task_dir
    task_dir=$(dirname "$file")
    local done_dir="${task_dir}/${RALPH_TASK_DONE_SUBDIR}"
    mkdir -p "$done_dir"

    local basename
    basename=$(basename "$file")
    local date_prefix
    date_prefix=$(date +%Y-%m-%d)
    local new_name="${date_prefix}_${basename}"

    mv "$file" "${done_dir}/${new_name}"

    # Clear current task if it matches
    if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
        local current
        current=$(cat "$RALPH_TASK_CURRENT_FILE")
        if [[ "$current" == "$file" ]]; then
            rm -f "$RALPH_TASK_CURRENT_FILE"
        fi
    fi

    echo -e "${GREEN}Done:${NC} ${done_dir}/${new_name}"
}

dir_failed() {
    local task_id="${1:-}"
    local reason="${2:-max iterations reached}"

    local file
    if [[ -z "$task_id" ]]; then
        # Use current task
        if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
            file=$(cat "$RALPH_TASK_CURRENT_FILE")
        else
            echo -e "${RED}No current task. Specify task ID.${NC}" >&2
            return 1
        fi
    elif [[ -f "$task_id" ]]; then
        file="$task_id"
    else
        file=$(find . -path "*tasks*${task_id}*" -name "*.md" -not -path "*/${RALPH_TASK_DONE_SUBDIR}/*" -not -path "*/${RALPH_TASK_FAILED_SUBDIR}/*" 2>/dev/null | head -1)
    fi

    if [[ -z "$file" || ! -f "$file" ]]; then
        echo -e "${RED}Task not found:${NC} $task_id" >&2
        return 1
    fi

    local task_dir
    task_dir=$(dirname "$file")
    local failed_dir="${task_dir}/${RALPH_TASK_FAILED_SUBDIR}"
    mkdir -p "$failed_dir"

    local basename
    basename=$(basename "$file")
    local date_prefix
    date_prefix=$(date +%Y-%m-%d)
    local new_name="${date_prefix}_${basename}"

    # Append failure reason to the file
    echo "" >> "$file"
    echo "## Failed" >> "$file"
    echo "**Date:** $(date)" >> "$file"
    echo "**Reason:** ${reason}" >> "$file"

    mv "$file" "${failed_dir}/${new_name}"

    # Clear current task if it matches
    if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
        local current
        current=$(cat "$RALPH_TASK_CURRENT_FILE")
        if [[ "$current" == "$file" ]]; then
            rm -f "$RALPH_TASK_CURRENT_FILE"
        fi
    fi

    echo -e "${RED}Failed:${NC} ${failed_dir}/${new_name}"
    echo -e "${YELLOW}Reason:${NC} ${reason}"
}

dir_count() {
    local project="${1:-}"
    local count=0

    local dirs
    if [[ -n "$project" ]]; then
        dirs="${project}/tasks"
    else
        dirs=$(dir_find_task_dirs)
    fi

    for dir in $dirs; do
        [[ ! -d "$dir" ]] && continue
        count=$((count + $(find "$dir" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')))
    done

    echo "$count"
}

# ============================================================================
# Queue Management
# ============================================================================

queue_build() {
    local project="${1:-}"

    mkdir -p "$RALPH_DIR"

    # Build prioritized queue
    local queue=()

    for pri in $PRIORITIES; do
        while IFS= read -r file; do
            [[ -n "$file" ]] && queue+=("$file")
        done < <(
            local dirs
            if [[ -n "$project" ]]; then
                dirs="${project}/tasks"
            else
                dirs=$(dir_find_task_dirs)
            fi
            for dir in $dirs; do
                [[ -d "$dir" ]] && ls -1 "$dir"/${pri}_*.md 2>/dev/null | sort
            done
        )
    done

    printf '%s\n' "${queue[@]}" > "$RALPH_TASK_QUEUE_FILE"
    echo "${#queue[@]}"
}

queue_next() {
    # Rebuild queue if file doesn't exist or is empty
    if [[ ! -f "$RALPH_TASK_QUEUE_FILE" ]] || [[ ! -s "$RALPH_TASK_QUEUE_FILE" ]]; then
        queue_build > /dev/null
    fi

    grep -v '^$' "$RALPH_TASK_QUEUE_FILE" 2>/dev/null | head -1
}

queue_load() {
    local task
    task=$(queue_next)

    if [[ -z "$task" ]]; then
        echo -e "${YELLOW}No tasks in queue${NC}"
        return 1
    fi

    # Save as current task
    echo "$task" > "$RALPH_TASK_CURRENT_FILE"

    # Remove from queue
    sed -i '' "1d" "$RALPH_TASK_QUEUE_FILE" 2>/dev/null || sed -i "1d" "$RALPH_TASK_QUEUE_FILE"

    # Generate PROMPT.md
    local title
    title=$(grep -m1 '^# ' "$task" 2>/dev/null | sed 's/^# //' || basename "$task" .md)

    local task_content
    task_content=$(cat "$task")

    local project_name
    project_name=$(dirname "$(dirname "$task")" | xargs basename)

    mkdir -p "$RALPH_DIR"
    cat > "${RALPH_DIR}/PROMPT.md" << EOF
# Current Task: ${title}

## Project
Working on: **${project_name}**

## Task Details
${task_content}

## Instructions
1. Complete the task described above
2. Commit your changes with a descriptive message
3. When fully complete, output: TASK_COMPLETE
4. If blocked or need human input, output: TASK_BLOCKED: <reason>

## Important
- Focus ONLY on this task
- Do not proceed past any STOP markers without explicit approval
- If the task is unclear, ask for clarification
EOF

    echo -e "${GREEN}Loaded:${NC} ${title}"
    echo -e "${BLUE}File:${NC} ${task}"
    echo -e "${BLUE}Prompt:${NC} ${RALPH_DIR}/PROMPT.md"
}

queue_current() {
    if [[ -f "$RALPH_TASK_CURRENT_FILE" ]]; then
        cat "$RALPH_TASK_CURRENT_FILE"
    fi
}

queue_skip() {
    local current
    current=$(queue_current)

    if [[ -z "$current" ]]; then
        echo -e "${YELLOW}No current task to skip${NC}"
        return 0
    fi

    # Add back to end of queue
    echo "$current" >> "$RALPH_TASK_QUEUE_FILE"
    rm -f "$RALPH_TASK_CURRENT_FILE"

    echo -e "${YELLOW}Skipped:${NC} $current"
}

# ============================================================================
# Task Attempt Tracking
# ============================================================================

get_task_attempts() {
    local task_file="$1"
    mkdir -p "$RALPH_DIR"
    touch "$RALPH_TASK_ATTEMPTS_FILE"

    grep "^${task_file}:" "$RALPH_TASK_ATTEMPTS_FILE" 2>/dev/null | cut -d: -f2 || echo "0"
}

increment_task_attempts() {
    local task_file="$1"
    local current_attempts
    current_attempts=$(get_task_attempts "$task_file")
    local new_attempts=$((current_attempts + 1))

    mkdir -p "$RALPH_DIR"
    touch "$RALPH_TASK_ATTEMPTS_FILE"

    # Remove old entry if exists
    grep -v "^${task_file}:" "$RALPH_TASK_ATTEMPTS_FILE" > "${RALPH_TASK_ATTEMPTS_FILE}.tmp" 2>/dev/null || true
    echo "${task_file}:${new_attempts}" >> "${RALPH_TASK_ATTEMPTS_FILE}.tmp"
    mv "${RALPH_TASK_ATTEMPTS_FILE}.tmp" "$RALPH_TASK_ATTEMPTS_FILE"

    echo "$new_attempts"
}

clear_task_attempts() {
    local task_file="$1"
    mkdir -p "$RALPH_DIR"
    touch "$RALPH_TASK_ATTEMPTS_FILE"

    grep -v "^${task_file}:" "$RALPH_TASK_ATTEMPTS_FILE" > "${RALPH_TASK_ATTEMPTS_FILE}.tmp" 2>/dev/null || true
    mv "${RALPH_TASK_ATTEMPTS_FILE}.tmp" "$RALPH_TASK_ATTEMPTS_FILE"
}

# ============================================================================
# Main Loop - Process all tasks
# ============================================================================

run_start() {
    local max_tasks="${1:-0}"  # 0 = unlimited
    local tasks_completed=0
    local tasks_failed=0

    echo -e "${BLUE}Starting ralph-tasks processing${NC}"
    echo "  Max tasks: ${max_tasks:-unlimited}"
    echo ""

    # Find ralph_loop.sh
    local ralph_loop=""
    if [[ -x "$RALPH_LOOP_SCRIPT" ]]; then
        ralph_loop="$RALPH_LOOP_SCRIPT"
    elif [[ -x "./ralph_loop.sh" ]]; then
        ralph_loop="./ralph_loop.sh"
    elif command -v ralph &> /dev/null; then
        ralph_loop="ralph"
    else
        echo -e "${RED}Error: Cannot find ralph_loop.sh or ralph command${NC}" >&2
        echo "Set RALPH_LOOP_SCRIPT or ensure ralph is installed" >&2
        return 1
    fi

    echo "Using: ${ralph_loop}"
    echo ""

    while true; do
        # Check task limit
        if [[ "$max_tasks" -gt 0 && "$tasks_completed" -ge "$max_tasks" ]]; then
            echo -e "${GREEN}Reached max tasks limit (${max_tasks})${NC}"
            break
        fi

        # Load next task
        echo "=========================================="
        echo -e "${BLUE}Loading next task...${NC}"

        if ! queue_load; then
            echo -e "${GREEN}No more tasks in queue!${NC}"
            break
        fi

        local current_task
        current_task=$(queue_current)
        local task_title
        task_title=$(grep -m1 '^# ' "$current_task" 2>/dev/null | sed 's/^# //' || basename "$current_task" .md)

        # Track attempts for this task
        local attempts
        attempts=$(get_task_attempts "$current_task")
        local new_attempts
        new_attempts=$(increment_task_attempts "$current_task")

        echo ""
        echo -e "${YELLOW}Working on:${NC} ${task_title} ${BLUE}(attempt ${new_attempts}/${RALPH_TASK_MAX_ATTEMPTS})${NC}"
        echo "=========================================="
        echo ""

        # Clear any stale response analysis from previous runs
        rm -f "${RALPH_DIR}/.response_analysis"

        # Run Ralph on this task
        local ralph_exit_code=0
        "$ralph_loop" || ralph_exit_code=$?

        # Check result
        local task_status="unknown"

        # If ralph_loop failed to run, mark as failed immediately
        if [[ "$ralph_exit_code" -ne 0 ]]; then
            task_status="failed"
        else
            # Ralph ran successfully - check if task was completed
            if [[ -f "${RALPH_DIR}/.response_analysis" ]]; then
                local exit_signal
                exit_signal=$(jq -r '.analysis.exit_signal // "false"' "${RALPH_DIR}/.response_analysis" 2>/dev/null || echo "false")
                local status
                status=$(jq -r '.analysis.status // "unknown"' "${RALPH_DIR}/.response_analysis" 2>/dev/null || echo "unknown")

                if [[ "$exit_signal" == "true" ]] || [[ "$status" == "COMPLETE" ]]; then
                    task_status="complete"
                fi
            fi

            # Also check PROMPT.md output for TASK_COMPLETE signal
            if [[ -f "${RALPH_DIR}/PROMPT.md" ]] && grep -q "TASK_COMPLETE" "${RALPH_DIR}/logs/"*.log 2>/dev/null; then
                task_status="complete"
            fi
        fi

        echo ""
        echo "=========================================="

        if [[ "$task_status" == "complete" ]]; then
            echo -e "${GREEN}Task completed!${NC}"
            clear_task_attempts "$current_task"
            dir_done
            ((tasks_completed++))
        else
            # Task failed - check if we should retry
            if [[ "$new_attempts" -lt "$RALPH_TASK_MAX_ATTEMPTS" ]]; then
                # Still have retries left - add task back to queue
                if [[ "$ralph_exit_code" -ne 0 ]]; then
                    echo -e "${YELLOW}Task failed (attempt ${new_attempts}/${RALPH_TASK_MAX_ATTEMPTS}): ralph_loop.sh exited with code ${ralph_exit_code}${NC}"
                else
                    echo -e "${YELLOW}Task did not complete (attempt ${new_attempts}/${RALPH_TASK_MAX_ATTEMPTS})${NC}"
                fi

                echo -e "${BLUE}Adding task back to queue for retry...${NC}"
                echo "$current_task" >> "$RALPH_TASK_QUEUE_FILE"
                rm -f "$RALPH_TASK_CURRENT_FILE"

                # Continue to next task (this one will be retried later)
                echo "Moving to next task..."
            else
                # Max attempts reached - move to failed
                echo -e "${RED}Task failed after ${RALPH_TASK_MAX_ATTEMPTS} attempts${NC}"

                if [[ "$ralph_exit_code" -ne 0 ]]; then
                    dir_failed "" "ralph_loop.sh failed with exit code ${ralph_exit_code} after ${RALPH_TASK_MAX_ATTEMPTS} attempts"
                else
                    dir_failed "" "Task did not complete within timeout after ${RALPH_TASK_MAX_ATTEMPTS} attempts"
                fi

                clear_task_attempts "$current_task"
                ((tasks_failed++))
            fi
        fi

        echo ""
        echo "Progress: ${tasks_completed} completed, ${tasks_failed} failed"
        echo ""

        # Small pause between tasks
        sleep 2
    done

    echo ""
    echo "=========================================="
    echo -e "${GREEN}Processing complete!${NC}"
    echo "  Tasks completed: ${tasks_completed}"
    echo "  Tasks failed: ${tasks_failed}"
    echo "=========================================="
}

# ============================================================================
# Main CLI
# ============================================================================

usage() {
    cat << 'EOF'
ralph-tasks - Unified task management for Ralph

USAGE:
    ralph-tasks [description]              Default: add medium priority task
    ralph-tasks h [description]            Add high priority task
    ralph-tasks m [description]            Add medium priority task
    ralph-tasks l [description]            Add low priority task
    ralph-tasks <command> [options]

COMMANDS:
    add <description>     Add a new task
        -p, --priority    Priority: H (high), M (medium), L (low). Default: M
        --project         Target project directory

    list                  List all tasks
        --project         Filter by project
        --status          Filter: pending, done, all. Default: pending

    next                  Show next task in queue
        --project         Filter by project

    show <task-id>        Show task details (partial match supported)

    done [task-id]        Mark task as done (default: current task)

    skip                  Skip current task (move to end of queue)

    queue                 Show queue status
        --load            Load next task into PROMPT.md

    start                 Process all tasks automatically
        --max-tasks       Stop after N tasks (default: unlimited)
                          Note: Failed tasks are retried up to 3 times before
                          being moved to failed/. After each failure, processing
                          continues with the next task.

    failed [task-id]      Mark task as failed (moves to failed/)

    count                 Count pending tasks

    help                  Show this help

CONFIGURATION (.ralphrc):
    RALPH_TASK_STORAGE=directory     # Storage backend
    RALPH_TASK_DIRS=a/tasks,b/tasks  # Task directories
    RALPH_TASK_DEFAULT_PROJECT=tldr  # Default project for 'add'

ALIASES (add to .zshrc/.bashrc):
    alias rt='ralph-tasks'
    alias rta='ralph-tasks add'
    alias rtl='ralph-tasks list'
    alias rtn='ralph-tasks next'
    alias rtd='ralph-tasks done'

EXAMPLES:
    ralph-tasks "fix login bug"                  # Add medium priority task
    ralph-tasks h "critical security issue"      # Add high priority task
    ralph-tasks l "update docs"                  # Add low priority task
    ralph-tasks add "refactor code" -p h         # Add high priority task
    ralph-tasks add "update docs" --project backend
    ralph-tasks list --status all
    ralph-tasks done fix_login
    ralph-tasks queue --load
    ralph-tasks start                            # Start processing all tasks
EOF
}

main() {
    load_config

    # Handle default behavior: if first arg is not a known command, treat as "add"
    local cmd="${1:-help}"

    # Check if it's a priority shortcut (h, m, l) or description
    case "$cmd" in
        h|H)
            # High priority add
            shift
            local description="$*"
            if [[ -z "$description" ]]; then
                echo -e "${RED}Error: Task description required${NC}" >&2
                return 1
            fi
            dir_add "$description" "H" ""
            return 0
            ;;
        m|M)
            # Medium priority add
            shift
            local description="$*"
            if [[ -z "$description" ]]; then
                echo -e "${RED}Error: Task description required${NC}" >&2
                return 1
            fi
            dir_add "$description" "M" ""
            return 0
            ;;
        l|L)
            # Low priority add
            shift
            local description="$*"
            if [[ -z "$description" ]]; then
                echo -e "${RED}Error: Task description required${NC}" >&2
                return 1
            fi
            dir_add "$description" "L" ""
            return 0
            ;;
        add|a|list|ls|next|n|show|s|done|d|complete|skip|queue|q|count|c|start|run|failed|fail|f|help|--help|-h)
            # Known command - process normally
            ;;
        *)
            # Not a known command - treat entire input as task description (medium priority)
            local description="$*"
            if [[ -z "$description" ]]; then
                usage
                return 0
            fi
            dir_add "$description" "M" ""
            return 0
            ;;
    esac

    # Process known commands
    shift || true

    case "$cmd" in
        add|a)
            local description=""
            local priority="M"
            local project=""

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    -p|--priority)
                        priority="$2"
                        shift 2
                        ;;
                    --project)
                        project="$2"
                        shift 2
                        ;;
                    -*)
                        echo "Unknown option: $1" >&2
                        return 1
                        ;;
                    *)
                        if [[ -z "$description" ]]; then
                            description="$1"
                        else
                            description="$description $1"
                        fi
                        shift
                        ;;
                esac
            done

            if [[ -z "$description" ]]; then
                echo -e "${RED}Error: Task description required${NC}" >&2
                return 1
            fi

            dir_add "$description" "$priority" "$project"
            ;;

        list|ls|l)
            local project=""
            local status="pending"

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --project) project="$2"; shift 2 ;;
                    --status) status="$2"; shift 2 ;;
                    *) shift ;;
                esac
            done

            dir_list "$project" "$status"
            ;;

        next|n)
            local project=""
            [[ "${1:-}" == "--project" ]] && project="$2"

            local next
            next=$(dir_next "$project")
            if [[ -n "$next" ]]; then
                dir_show "$next"
            else
                echo -e "${YELLOW}No pending tasks${NC}"
            fi
            ;;

        show|s)
            dir_show "${1:-}"
            ;;

        done|d|complete)
            dir_done "${1:-}"
            ;;

        skip)
            queue_skip
            ;;

        queue|q)
            if [[ "${1:-}" == "--load" ]]; then
                queue_load
            else
                local count
                count=$(queue_build)
                echo -e "${BLUE}Queue:${NC} ${count} tasks"

                local current
                current=$(queue_current)
                if [[ -n "$current" ]]; then
                    local title
                    title=$(grep -m1 '^# ' "$current" 2>/dev/null | sed 's/^# //' || basename "$current" .md)
                    echo -e "${GREEN}Current:${NC} ${title}"
                    echo "         ${current}"
                fi

                echo ""
                echo "Pending:"
                dir_list "" "pending"
            fi
            ;;

        count|c)
            dir_count "${1:-}"
            ;;

        start|run)
            local max_tasks=0

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --max-tasks|-t)
                        max_tasks="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            run_start "$max_tasks"
            ;;

        failed|fail|f)
            dir_failed "${1:-}" "${2:-}"
            ;;

        help|--help|-h)
            usage
            ;;

        *)
            echo -e "${RED}Unknown command:${NC} $cmd" >&2
            echo "Run 'ralph-tasks help' for usage"
            return 1
            ;;
    esac
}

# Run if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
